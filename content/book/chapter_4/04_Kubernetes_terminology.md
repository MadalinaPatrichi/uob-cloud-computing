Kubernetes primitives

So let’s go a little bit into primitives, because the vocabulary is very important, if you don’t already know. One problem that I have with new technologies is that it takes me a really long time to wrap my head around the vocabulary, but then as soon as I get it, all of a sudden a light bulb goes off and I can say, okay, now I can do things.

Let’s talk a little bit about Kubernetes vocab, such that we can hopefully understand more easily its architecture and the demo that we’re going to see a bit later, and that everything is going to make a little bit more sense.

So, the first primitive that I want for people to remember is a pod. A pod is a little bit weird if you’ve never used Kubernetes before, because it is something super specific to this technology and it’s not exactly a container. Hopefully, all of you know what containers are. Basically a container, or a Docker container has an application in it that runs independently, it could be anything. The idea with a Docker container originally and the best practice was that one process runs in one container. Before Kubernetes existed, people tried to tinker with that a lot, so they would put their app in there, and then they add a supervisor in there, a logging app in there, and all this was done by messing around with the bash script to make it look like there was only one process running, but it really wasn’t. The cool thing about Kubernetes is that now, you don’t have to worry about all that nonsense, so you can have you app in one container, you can have your statistics app, they can sit next to each other in what’s called a pod. A pod is, you guessed it, a group of containers; and those containers see each other as localhost. That is super cool, isn’t it? So you can have your app running by itself, nginx running by itself and they know about each other as if they were the same entity.

Next, I want to tell you about deployment, because this is really kind of important to you; you have your application in a container, you’ve maybe thought what you need in your pod, so you have the ingredients. I like to think of a deployment as a recipe. So, you want to cook a thing, you’ve got the ingredients and you need a recipe. If you look at the deployment example here, it’s very bare-bones, it has the number of replicas, a couple of labels, it exposes some ports. So, with this, you basically say to Kubernetes, we need to get this done and this is how I want you to do it. And what is really cool is that I give this to Kubernetes once, and it makes sure that this is always true.

For example, in my config here, I’ve got replicas equals two, if there are ever not two replicas, because, for instance a pod fails, or someone accidentally deletes one, Kubernetes steps in and says no, there are supposed to be two, I’ll take care of this. And it will go and schedule another one immediately. As you can imagine, you can get really complex with this, there are some environment variables you can read those in from different data sources and you can change those at run-time.

A deployment will always update the container if there is any diff.

And then, this is the last primitive that I want to tell you about, even though there are sooo many, but I don’t want to bombard you with too much information. However, this is the last important one that I think is going to help, and that is a service. So, you’ve deployed your app, the pods are running on Kubernetes, but how do you get people to look at them, how do you have your customers, or your devs, or whomever, access those containers? Well, you need to expose them in a certain way, right?

The way we expose them classically is through a proxy, or a load-balancer, something like that, and that usually points to your servers and you’re good to go. In Kubernetes, the way that that’s done is through something called a service. A service is basically the analog of a load-balancer. It allows us to access the pods in a consistent way; so the pods, as you can imagine, because Kubernetes gives us the flexibility and the power to do so, they can go away, and come back, and new ones can start and you can change them and that all happens behind the abstraction of a service. You don’t want your customers seeing that and you don’t want to statically address them, so the service can communicate in such a way that your customers don’t experience that.
