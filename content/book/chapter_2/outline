- Deployment architecture, how does that map onto: VMs, networks, loadbalancers, etc.
- - Dig into basic architecture - network and VM layout
- - (Alternative architectures? Multiple subnet deployment etc.)
- VM is an analogue to a "real host". We can stand up lots of these easily - more than we could get hold of physical hardware
- - well done! now you need to manage more operating system instances
- - start by looking at doing this "manually", with a very simple architecture, look at automation afterwards
- booting
- - with an ssh key
- - making an ssh key 
- - First instance boot has an option to create a network for you. We'll use that, then look at it.
- network setup
- - What are the pieces you'll see? Explain with reference to a diagram. Router, subnets, host, IG.
- - What does a TCP connection look like?
- - Very brief mention of NAT. (More later)
- Things won't talk to each other by default!
- - You need to turn stuff on explicitly
- - Security groups
- - - What is the path of a request from a user's browser to the app (and to the DB)?
- - - Need to ensure these pieces can communicate
- - host firewalls
- - - defence in depth. Quick cookbook for opening up ports.
- - - We'll see the use of something like nc as a testing tool.
- installing the software (less interesting in the lecture - elide it)
- - mysql:
- - - making it run
- - - testing: mysql command-line tool
- - - making it run on reboot
- - - configuring credentials
- - - checking communication
- - - - netstat, what constitutes a TCP connection (explain the connection 4-tuple)
- - - What about backups?
- - - - maybe dumps something to object store.
- - - robustness: clustering? (exercise for the reader?)
- - java
- - - making it run
- - - making it run on reboot
- - - configuring in the same credentials
- - - schema management, different creds.
- - - What about db migrations?
- - - backups?
- - - - well, the state is stored in the DB. what about the configuration?
- - - robustness: clustering
- - implications for the "Google login" - can't guarantee that the callback hits the same host that the subsequent user request will.
- Locating the app on the web
- - By IP address
- - Internal versus external
- - - NAT - explain this in a bit more detail
- - By name
- - DNS
- - - your own domains
- - - where to point CNAMEs / A records
- - Securing it
- - - security certs
- - - - self-signed?
- - - - let's encrypt?
- - - - the certificate needs to identify the service *as the client sees it*
- - - what about securing internal traffic?
- - - - It's a good idea.
- - LBaaS at the front end
- - - This becomes the IP address you want DNS to point to
- - GeoDNS for regional scalability
- - - Brief discussion of implications for application architecture: synchronisation, etc.
- Checking it all works
- Repeatability
- - from the web console to command-line tools, scripting
- - targeted scripting tools (eg terraform, others..?)
- - - some tools target host configuration, some target infrastructure layout, some try to do a bit of both.
- What about updates?
- - Ideal: I can deliver updates with no user interruption. I can roll updates out piecemeal and cut over to them.
- - What kind of implications does this have? Schema, object versioning. Writing software that's forwards- and backwards-compatible. one logical update may require a multi-stage deployment
